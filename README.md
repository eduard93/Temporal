# Temporal
Хранение данных с историей в Caché.

# Установка

1. Загрузите пакет Temporal и скомпилируйте его

# Идея

Каждое свойсво Property хранится в отдельном узле: `Package.ClassD.PropertyD(id, timestamp) = val` где:
  - Package.ClassD - глобал данных класса
  - Package.ClassD.PropertyD - глобал свойства Property
  - id - первичный ключ
  - timestamp - дата/время в формате [unixtime](https://en.wikipedia.org/wiki/Unix_time)
  - val - значение свойства (Для типа данных пишем значение, для объекта - id, сериализуемые сериализуем, стримы оборачиваем в классы и пишем id, списки/массивы объектов сериализуем в списки/массивы id, а дальше списки/массивы данных сериализуем)
 
Также автоматически генерируется узел: `Package.ClassD.PropertyD(id) = val` с актуальным значением свойства.

# Геттер свойства

## Объектный контекст

Загрузка в память идёт при первом обращении, дальше берём из памяти. Алгоритм такой:

1. Если значение есть в памяти, то берём его. ВЫХОД
2. Если нужна последняя версия данных, то берём её
3. Если нужны данные на момент %ts, то пытаемся взять данные именно на момент %ts
4. Если не нашли 3, то берём ближайшее следующее/предыущее значение
5. Если нужно значение на дату >%ts, но его не существует, то берём предыдущее значение (должно быть аналогично 2? TODO)
6. Записываем полученное значение в память
7. Возвращаем значение 

## SQL контекст

Для SQL всё аналогично, но выполняются только пункты  2-5,7.

  
# Ограничения
 
 - Нет INSERT/UPDATE - в принципе можно написать триггер
 - Не решена проблема одновременного обновления - Lock придумали как раз для этого
 - Нет индексов на текущие значения - не вижу как решать
 - Временные переменные %ts/%state при использовании в COS SQL надо либо new до либо удалять после
 - Нет хранения отметок изменения объектов - Надо? Use case? Как? Проецировать в класс `{class, id, ts, diff}`. В таком виде сделать представляется вполне возможнвм
 - Одно и то же свойство нельзя обновлять чаще чем 1 раз в секунду - решается добавлением ещё 3 знаков для миллисекунд - это есть в Caché и в коде закоментировано
 

# Использование

Класс-пример `Temporal.Simple`. 

1. Для начала сгенерируйте данные: `do ##class(Temporal.Simple).populate(count, updCycles, rebuild)` Cоздает count записей, обновляет значение каждой updCycles раз, удаляет все данные, если установлен rebuild=1. По умолчанию создаёт 1kk записей, обновляя каждую по 10 раз.
2. Для открытия объекта на определённый момент времени (ro) выполните: `set obj = ##class(Temporal.Simple).openAt(id, concurrency, .sc, state, timestamp, debug)`, где: 
  - id - первичный ключ
  - concurrency [-1] - режим открытия объекта
  - sc - статус
  - state [1] - какое значение брать, если на timestamp значения нет. 1 - следующее, -1 - предыдущее
  - timestamp [now] - дата/время в формате Timestamp `2017-01-19 00:18:14`
  - debug [0] - если 1, то timestamp в фррмате unixtime `1484838070`
  
3. Для выполнения запроса на определённый момент времени, добавьте во WHERE условие `Temporal.AtTime(state, timestamp, debug)=1`, переменные аналогичны 2.
4. Для открытия последней версии объекта (rw) используйте `%OpenId(id, concurrency, .sc)`

# TODO
  - Унифицировать %ts, ..%ts, timestamp
  - 



# Temporal
Store temporal data in Caché
